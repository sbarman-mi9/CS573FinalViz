<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CS573 Final Project</title>
    <script src="scripts/d3.min.js" type="text/javascript"></script>
    <script src="scripts/topojson.v1.js" type="text/javascript"></script>
    <script src="scripts/underscore-min.js" type="text/javascript"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js" charset="utf-8"></script>
    <link href="styles/style.css" type="text/css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet" type="text/css">
    <script src="scripts/main_map.js"></script>
</head>
<style>

    body {
        font: 10px sans-serif;
    }

    .chart {
        background: #fff;
    }

    p {
        font: 12px helvetica;
    }


    .axis path, .axis line {
        fill: none;
        stroke: #000;
        stroke-width: 2px;
        shape-rendering: crispEdges;
    }

    button {
        position: absolute;
        right: 50px;
        top: 10px;
    }

    /*parallel plot*/

   #parallelContainer svg {
        font: 10px sans-serif;
    }

    #parallelContainer  .background path {
        fill: none;
        stroke: #ddd;
        shape-rendering: crispEdges;
    }

    #parallelContainer   .foreground path {
        fill: none;
        stroke: steelblue;
    }

    #parallelContainer  .brush .extent {
        fill-opacity: .3;
        stroke: #fff;
        shape-rendering: crispEdges;
    }

    #parallelContainer   .axis line,
    #parallelContainer  .axis path {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    #parallelContainer   .axis text {
        text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
        cursor: move;
    }

</style>
<body>
    <div id="tooltip"></div>
    <div id = "map">
        <svg width = "615px" height = "375px" class = "big"></svg>
    </div>
    <div>&nbsp;</div>
<div>
    <select id="parallelTown">
        <option value="Boston">Boston</option>
        <option value="Brockton">Brockton</option>
        <option value="Brookline">Brookline</option>

        <option value="Cambridge">Cambridge</option>
        <option value="Fall River">Fall River</option>
        <option value="Framingham">Framingham</option>

        <option value="Haverhill">Haverhill</option>
        <option value="Lawrence">Lawrence</option>
        <option value="Lowell">Lowell</option>

        <option value="Lynn">Lynn</option>
        <option value="Malden">Malden</option>
        <option value="Medford">Medford


        <option value="New bedford">New bedford</option>
        <option value="Plymouth">Plymouth</option>
        <option value="Quincy">Quincy</option>


        <option value="Somerville">Somerville</option>
        <option value="Springfield">Springfield</option>
        <option value="Taunton">Taunton</option>

        <option value="Waltham">Waltham</option>
        <option value="Worcester">Worcester</option>


    </select>
</div>
<div id="themeRiverContainer"></div>
<div id="parallelContainer"></div>
<script>
    
    
    
    
    createParallelPlot();
    createThemeRiver();
    $("#parallelTown").change(function () {
        createParallelPlot();
        createThemeRiver();
    });


   function createThemeRiver() {

       $('#themeRiverContainer').empty();
       chart("data/city&type.csv", "orange");

       var datearray = [];
       var colorrange = [];
   }

       function chart(csvpath, color) {

           if (color == "blue") {
               colorrange = ["#045A8D", "#2B8CBE", "#74A9CF", "#A6BDDB", "#D0D1E6", "#F1EEF6"];
           }
           else if (color == "pink") {
               colorrange = ["#980043", "#DD1C77", "#DF65B0", "#C994C7", "#D4B9DA", "#F1EEF6"];
           }
           else if (color == "orange") {
               colorrange = ["#B30000", "#E34A33", "#FC8D59", "#FDBB84", "#FDD49E", "#FEF0D9"];
           }
           strokecolor = colorrange[0];

           var format = d3.time.format("%m/%d/%y");

           var margin = {top: 20, right: 40, bottom: 30, left: 30};
           var width = document.body.clientWidth - margin.left - margin.right;
           var height = 400 - margin.top - margin.bottom;

           var tooltip = d3.select("#themeRiverContainer")
                   .append("div")
                   .attr("class", "remove")
                   .style("position", "absolute")
                   .style("z-index", "20")
                   .style("visibility", "hidden")
                   .style("top", "30px")
                   .style("left", "55px");

           var x = d3.scale.ordinal()
                   .rangePoints([0, width]);

           var y = d3.scale.linear()
                   .range([height, 0]);

           var z = d3.scale.ordinal()
                   .range(colorrange);

           var xAxis = d3.svg.axis()
                   .scale(x)
                   .orient("bottom");
                   //.ticks(d3.time.weeks);

           var yAxis = d3.svg.axis()
                   .scale(y);

           var yAxisr = d3.svg.axis()
                   .scale(y);

           var stack = d3.layout.stack()
                   .offset("silhouette")
                   .values(function(d) { return d.values; })
                   .x(function(d) { return d.date; })
                   .y(function(d) { return d.value; });

           var nest = d3.nest()
                   .key(function(d) { return d.key; });

           var area = d3.svg.area()
                   .interpolate("cardinal")
                   .x(function(d) { return x(d.date); })
                   .y0(function(d) { return y(d.y0); })
                   .y1(function(d) { return y(d.y0 + d.y); });

           var svg = d3.select("#themeRiverContainer").append("svg")
                   .attr("width", width + margin.left + margin.right)
                   .attr("height", height + margin.top + margin.bottom)
                   .append("g")
                   .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

           var graph = d3.csv(csvpath, function(data) {

               data = data.filter(function (row) {
                   return row['City'] == $('#parallelTown').val();

               })

               var headers = ['12 AM','1 AM','2 AM','3 AM','4 AM','5 AM','6 AM','7 AM','8 AM','9 AM','10 AM','11 AM','12 PM','1 PM','2 PM','3 PM','4 PM','5 PM','6 PM','7 PM','8 PM','9 PM','10 PM','11 PM'];

               var dataArray=[]
               var modData = (headers.map(function(value) {
                   return data.map(function(d) {
                       var t={key: d.Type,date: value, value: +d[value]};
                       dataArray.push(t);
                       return {key: d.Type,date: value, value: +d[value]};
                   });
               }));
//               data.forEach(function(d) {
//                   d.date = format.parse(d.date);
//                   d.value = +d.value;
//               });
data=dataArray;
               var layers = stack(nest.entries(dataArray));

             //x.domain(d3.extent(dataArray, function(d) { return d.date; }));
             y.domain([0, d3.max(dataArray, function(d) { return d.y0 + d.y; })]);

              x.domain(headers);
               //y.domain([0, 300]);
               svg.selectAll(".layer")
                       .data(layers)
                       .enter().append("path")
                       .attr("class", "layer")
                       .attr("d", function(d) { return area(d.values); })
                       .style("fill", function(d, i) { return z(i); });


               svg.append("g")
                       .attr("class", "x axis")
                       .attr("transform", "translate(0," + height + ")")
                       .call(xAxis);

               svg.append("g")
                       .attr("class", "y axis")
                       .attr("transform", "translate(" + width + ", 0)")
                       .call(yAxis.orient("right"));

               svg.append("g")
                       .attr("class", "y axis")
                       .call(yAxis.orient("left"));

               svg.selectAll(".layer")
                       .attr("opacity", 1)
                       .on("mouseover", function(d, i) {
                           svg.selectAll(".layer").transition()
                                   .duration(250)
                                   .attr("opacity", function(d, j) {
                                       return j != i ? 0.6 : 1;
                                   })})

                       .on("mousemove", function(d, i) {
//                           mousex = d3.mouse(this);
//                           mousex = mousex[0];
//                           var invertedx = x.invert(mousex);
//                           invertedx = invertedx.getMonth() + invertedx.getDate();
//                           var selected = (d.values);
//                           for (var k = 0; k < selected.length; k++) {
//                               datearray[k] = selected[k].date
//                               datearray[k] = datearray[k].getMonth() + datearray[k].getDate();
//                           }
//
//                           mousedate = datearray.indexOf(invertedx);
//                           pro = d.values[mousedate].value;

                           d3.select(this)
                                   .classed("hover", true)
                                   .attr("stroke", strokecolor)
                                   .attr("stroke-width", "0.5px"),
                                   tooltip.html( "<p>" + d.key + "</p>" ).style("visibility", "visible");

                       })
                       .on("mouseout", function(d, i) {
                           svg.selectAll(".layer")
                                   .transition()
                                   .duration(250)
                                   .attr("opacity", "1");
                           d3.select(this)
                                   .classed("hover", false)
                                   .attr("stroke-width", "0px"), tooltip.html( "<p>" + d.key  + "</p>" ).style("visibility", "hidden");
                       })

               var vertical = d3.select(".chart")
                       .append("div")
                       .attr("class", "remove")
                       .style("position", "absolute")
                       .style("z-index", "19")
                       .style("width", "1px")
                       .style("height", "380px")
                       .style("top", "10px")
                       .style("bottom", "30px")
                       .style("left", "0px")
                       .style("background", "#fff");

//               d3.select(".chart")
//                       .on("mousemove", function(){
//                           mousex = d3.mouse(this);
//                           mousex = mousex[0] + 5;
//                           vertical.style("left", mousex + "px" )})
//                       .on("mouseover", function(){
//                           mousex = d3.mouse(this);
//                           mousex = mousex[0] + 5;
//                           vertical.style("left", mousex + "px")});
         });
   }



    function createParallelPlot() {
        $('#parallelContainer').empty();
        var marginParallel = {top: 30, right: 220, bottom: 10, left: 220},
                widthParallel = document.body.clientWidth - marginParallel.left - marginParallel.right,
                heightParallel = 700 - marginParallel.top - marginParallel.bottom;

        var xParallel = d3.scale.ordinal().rangePoints([0, widthParallel], 1),
                yParallel = {},
                draggingParallel = {};

        var lineParallel = d3.svg.line(),
                axisParallel = d3.svg.axis().orient("left"),
                backgroundParallel,
                foregroundParallel;

        var svgParallel = d3.select("#parallelContainer").append("svg")
                .attr("width", widthParallel + marginParallel.left + marginParallel.right)
                .attr("height", heightParallel + marginParallel.top + marginParallel.bottom)
                .append("g")
                .attr("transform", "translate(" + marginParallel.left + "," + marginParallel.top + ")");

        d3.csv("data/street&time.csv", function (error, streets) {
            streets = streets.filter(function (row) {
                return row['City'] == $('#parallelTown').val();
                ;
            })
            // Extract the list of dimensionsParallel and create a scale for each.
            xParallel.domain(dimensionsParallel = d3.keys(streets[0]).filter(function (d) {
                if (d === "City") return false;

                if (d === "Street") {
                    yParallel[d] = d3.scale.ordinal()
                            .domain(streets.map(function (p) {
                                return p[d];
                            }))
                            .rangePoints([heightParallel, 0]);

                }
                else {
                    yParallel[d] = d3.scale.linear()
                            .domain([0,25])

                            .range([heightParallel, 0]);
                }

                return true;
            }));

            // Add grey background lines for context.
            backgroundParallel = svgParallel.append("g")
                    .attr("class", "background")
                    .selectAll("path")
                    .data(streets)
                    .enter().append("path")
                    .attr("d", path);

            // Add blue foreground lines for focus.
            foregroundParallel = svgParallel.append("g")
                    .attr("class", "foreground")
                    .selectAll("path")
                    .data(streets)
                    .enter().append("path")
                    .attr("d", path);

            // Add a group element for each dimension.
            var gParallel = svgParallel.selectAll(".dimension")
                    .data(dimensionsParallel)
                    .enter().append("g")
                    .attr("class", "dimension")
                    .attr("transform", function (d) {
                        return "translate(" + xParallel(d) + ")";
                    })
                    .call(d3.behavior.drag()
                            .origin(function (d) {
                                return {x: xParallel(d)};
                            })
                            .on("dragstart", function (d) {
                                draggingParallel[d] = xParallel(d);
                                backgroundParallel.attr("visibility", "hidden");
                            })
                            .on("drag", function (d) {
                                draggingParallel[d] = Math.min(widthParallel, Math.max(0, d3.event.x));
                                foregroundParallel.attr("d", path);
                                dimensionsParallel.sort(function (a, b) {
                                    return position(a) - position(b);
                                });
                                xParallel.domain(dimensionsParallel);
                                gParallel.attr("transform", function (d) {
                                    return "translate(" + position(d) + ")";
                                })
                            })
                            .on("dragend", function (d) {
                                delete draggingParallel[d];
                                transition(d3.select(this)).attr("transform", "translate(" + xParallel(d) + ")");
                                transition(foregroundParallel).attr("d", path);
                                backgroundParallel
                                        .attr("d", path)
                                        .transition()
                                        .delay(500)
                                        .duration(0)
                                        .attr("visibility", null);
                            }));

            // Add an axis and title.
            gParallel.append("g")
                    .attr("class", "axis")
                    .each(function (d) {
                        d3.select(this).call(axisParallel.scale(yParallel[d]));
                    })
                    .append("text")
                    .style("text-anchor", "middle")
                    .attr("y", -9)
                    .text(function (d) {
                        return d;
                    });

            // Add and store a brush for each axis.
            gParallel.append("g")
                    .attr("class", "brush")
                    .each(function (d) {
                        d3.select(this).call(yParallel[d].brush = d3.svg.brush().y(yParallel[d]).on("brushstart", brushstart).on("brush", brush));
                    })
                    .selectAll("rect")
                    .attr("x", -8)
                    .attr("width", 16);
        });

        function position(d) {
            var v = draggingParallel[d];
            return v == null ? xParallel(d) : v;
        }

        function transition(g) {
            return g.transition().duration(500);
        }

        // Returns the path for a given data point.
        function path(d) {
            return lineParallel(dimensionsParallel.map(function (p) {
                return [position(p), yParallel[p](d[p])];
            }));
        }

        function brushstart() {
            d3.event.sourceEvent.stopPropagation();
        }

        // Handles a brush event, toggling the display of foreground lines.
        function brush() {
            var actives = dimensionsParallel.filter(function (p) {
                        return !yParallel[p].brush.empty();
                    }),
                    extents = actives.map(function (p) {
                        return yParallel[p].brush.extent();
                    });
            foregroundParallel.style("display", function (d) {
                return actives.every(function (p, i) {
                    return extents[i][0] <= d[p] && d[p] <= extents[i][1];
                }) ? null : "none";
            });
        }


    }
</script>




